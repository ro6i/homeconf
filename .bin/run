#!/bin/bash

set -e

if [ -z "$RUN_CLI_DIR" ]
then
  >&2 echo -e 'RUN_CLI_DIR not specified'
  exit 1
fi

function warn {
  if [ -t 1 ]
  then
    >&2 echo -e "$(tput setaf 9)WARN: $(tput setaf 3)${1}$(tput sgr0)"
  else
    >&2 echo -e "WARN $1"
  fi
}

function capture_match_file {
  if $(cat "$RUN_CLI_DIR/$2" | grep -q "^$1\$")
  then
    CAPTURED="$1"
  else
    MESSAGE="value [$1] is not at [$2]"
  fi
}

function capture_match_values {
  for el in "${_arg_list[@]}";
  do
    [[ "$el" == "$1" ]] && CAPTURED="$1"
  done
  if [[ -z "$CAPTURED" ]]
  then
    MESSAGE="value [$1] is not in [${_arg_list[@]}]"
  fi
}

function capture_uuid {
  if [[ "$1" =~ ^\{?[A-F0-9a-f]{8}-[A-F0-9a-f]{4}-[A-F0-9a-f]{4}-[A-F0-9a-f]{4}-[A-F0-9a-f]{12}\}?$ ]]
  then
    CAPTURED="$1"
  else
    MESSAGE="[$1] not UUID"
  fi
}

function capture_date {
  if [[ $(date "+%Y-%m-%d" -d "$1") == "$1" ]]
  then
    CAPTURED="$1"
  else
    MESSAGE="[$1] not DATE"
  fi
}

function capture_text {
  local is_set=
  local op="$2"
  local len="$3"
  case "$op" in
    eq)
      if [[ "${#1}" -eq "$len" ]]; then is_set=1; fi
      ;;
    lt)
      if [[ "${#1}" -lt "$len" ]]; then is_set=1; fi
      ;;
    gt)
      if [[ "${#1}" -gt "$len" ]]; then is_set=1; fi
      ;;
    le)
      if [[ "${#1}" -le "$len" ]]; then is_set=1; fi
      ;;
    ge)
      if [[ "${#1}" -ge "$len" ]]; then is_set=1; fi
      ;;
  esac
  if [[ ! -z "$is_set" ]]
  then
    CAPTURED="$2"
  else
    MESSAGE="[$1] out of range"
  fi
}

function capture_regex {
  if $(echo "$1" | grep -q "$2")
  then
    CAPTURED="$1"
  else
    MESSAGE="[$1] does not match /$2/"
  fi
}

function capture_integer {
  if $(echo "$1" | grep -q '^[0-9]*$')
  then
    CAPTURED="$1"
  else
    MESSAGE="[$1] not integer"
  fi
}

function _one {
  local mode="$1"
  local index="$2"
  local val="${args[$index]}"
  local var="$3"
  local type="$4"

  case "$mode" in
    assert)
      if [[ -z "$val" ]]
      then
        warn "value [$var] must have value"
        exit 1
      fi
      ;;
    *)
      ;;
  esac

  if [[ -z "$var" ]]
  then
    warn "assertion must have variable name in second argument"
    exit 1
  fi

  CAPTURED=

  case "$type" in
    from)
      capture_match_file "$val" "$5"
      ;;
    opts)
      _arg_list=(${@:5})
      capture_match_values "$val"
      ;;
    uuid)
      capture_uuid "$val"
      ;;
    date)
      capture_date "$val"
      ;;
    text)
      capture_text "$val" "$5" "$6" "$7"
      ;;
    regex)
      capture_regex "$val" "$5"
      ;;
    integer)
      capture_integer "$val"
      ;;
    *)
      warn "unknown type [$type]"
      exit 1
      ;;
  esac

  case "$mode" in
    assert)
      if [[ -z "$CAPTURED" ]]
      then
        warn "$MESSAGE"
        exit 1
      fi
      ;;
    optin)
      if [[ ! -z "$val"  && ! -z "$MESSAGE" ]]
      then
        warn "$MESSAGE"
        exit 1
      fi
      ;;
    *)
      ;;
  esac

  if [[ "$var" != '_' ]]
  then
    eval "$var='$CAPTURED'"
  fi
}

# high level interface
function assert {
  _one assert "$@"
}

function optin {
  _one optin "$@"
}


args=($@)

SCRIPT_NAME="$1"
shift 1


# include script that may contain customizations, functions, settings
GLOBAL_ENV_PATH="$RUN_CLI_DIR/.env.sh"
[[ -f "$GLOBAL_ENV_PATH" ]] && . "$GLOBAL_ENV_PATH"

# include the actual runnable script
# lib functions (e.g. assert, optin) can be invoked inside run script
. "$RUN_CLI_DIR/run-${SCRIPT_NAME}.sh"


[[ $(type -t main) != function ]] && warn 'main function not found' && exit 1

main
